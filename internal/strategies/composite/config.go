package composite

import (
	"fmt"

	"github.com/ajiwo/ratelimit/strategies"
	"github.com/ajiwo/ratelimit/utils/builderpool"
)

// Config represents a dual-strategy configuration
type Config struct {
	BaseKey      string            // Base key for composite storage key generation
	Primary      strategies.Config // Primary strategy (hard limiter)
	Secondary    strategies.Config // Secondary strategy (smoother)
	compositeKey string            // Cached composite storage key
}

// Validate performs configuration validation for the composite strategy.
//
// Returns an error if any of the following conditions are met:
//   - BaseKey is empty
//   - Primary strategy is nil
//   - Secondary strategy is nil
//   - Primary strategy validation fails
//   - Secondary strategy validation fails
//   - Primary strategy doesn't support CapPrimary capability
//   - Secondary strategy doesn't support CapSecondary capability
//
// Validation ensures both strategies are properly configured and compatible
// for dual-strategy operation with atomic coordination.
func (c *Config) Validate() error {
	if c.BaseKey == "" {
		return fmt.Errorf("composite config base key cannot be empty")
	}
	if c.Primary == nil {
		return fmt.Errorf("composite config primary strategy cannot be nil")
	}
	if c.Secondary == nil {
		return fmt.Errorf("composite config secondary strategy cannot be nil")
	}

	// Validate individual configs
	if err := c.Primary.Validate(); err != nil {
		return fmt.Errorf("primary config validation failed: %w", err)
	}
	if err := c.Secondary.Validate(); err != nil {
		return fmt.Errorf("secondary config validation failed: %w", err)
	}

	// Check capabilities
	if !c.Primary.Capabilities().Has(strategies.CapPrimary) {
		return fmt.Errorf("primary strategy must support primary capability")
	}
	if !c.Secondary.Capabilities().Has(strategies.CapSecondary) {
		return fmt.Errorf("secondary strategy must support secondary capability")
	}

	return nil
}

// ID returns the unique identifier for the composite strategy.
//
// This method implements the Config interface and returns StrategyComposite,
// which is used for logging, debugging, and strategy selection.
func (c *Config) ID() strategies.ID {
	return strategies.StrategyComposite
}

// Capabilities returns the supported capabilities of the composite strategy.
//
// This strategy supports:
//   - CapPrimary: Acts as a primary limiter (contains a primary strategy)
//   - CapSecondary: Supports secondary operation (contains a secondary strategy)
//
// Note: Composite strategy does NOT support CapQuotas directly. If multi-quota
// support is needed, use a fixed window strategy as either the primary or
// secondary component.
func (c *Config) Capabilities() strategies.CapabilityFlags {
	return strategies.CapPrimary | strategies.CapSecondary
}

// WithKey applies a new fully-qualified-key to the composite config.
//
// This method generates a composite storage key using the format:
//
//	"{BaseKey}:{key}:c"
//
// The ":c" suffix distinguishes composite state from individual strategy states.
// Primary and secondary configs are not given keys directly since they use
// the singleKeyAdapter internally for coordinated storage.
func (c *Config) WithKey(key string) strategies.Config {
	sb := builderpool.Get()
	defer builderpool.Put(sb)
	sb.WriteString(c.BaseKey)
	sb.WriteString(":")
	sb.WriteString(key)
	sb.WriteString(":c")
	c.compositeKey = sb.String()

	return c
}

// CompositeKey returns the composite storage key.
//
// This key is used to store the composite state that coordinates both
// primary and secondary strategies. The key is generated by WithKey()
// using the format "{BaseKey}:{key}:c".
func (c *Config) CompositeKey() string {
	return c.compositeKey
}

// GetMaxRetries returns the maximum retry attempts for CAS operations.
//
// Returns the minimum of the primary and secondary strategy retry counts to ensure
// both strategies can complete their operations within the retry budget.
func (c *Config) GetMaxRetries() int {
	return min(c.Primary.GetMaxRetries(), c.Secondary.GetMaxRetries())
}

// WithMaxRetries applies the retry limit to both primary and secondary configs.
//
// When retries is 0, both strategies will automatically calculate their optimal
// max retries values based on their specific implementations. When retries > 0,
// the explicit value will be applied to both strategies, overriding their
// automatic calculations.
func (c *Config) WithMaxRetries(retries int) strategies.Config {
	c.Primary = c.Primary.WithMaxRetries(retries)
	c.Secondary = c.Secondary.WithMaxRetries(retries)
	return c
}
